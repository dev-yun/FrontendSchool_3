<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>document</title>
  </head>
  <body>
    <script>
      const text = "ABCDEFGHIJK";

      // String 메서드
      console.log(text.length); // 사실 length는 메서드는 아니고 길이를 반환하는 프로퍼티이다.
      console.log(text.indexOf("E")); // indexOf에는 정규표현식을 허용하지 않음, 검색 시작 index를 지정 가능 (indexOf("찾는 문자", 검색 시작 index))
      console.log(text.search("E")); // 정규표현식 허용, 검색 시작 index를 지정할 수 없음. indexOf와 마찬가지로 없는 문자는 -1반환

      let regExp = /CD/;
      console.log(text.search(regExp));

      console.log(text.slice(4, 7)); // 4번 index부터 6번 index까지 출력 (7번 전까지)
      console.log(text.substring(4, 7)); // 4번 index부터 6번 index까지 출력 (7번 전까지)
      console.log(text.substr(4, 7)); // 4번 index부터 7개 검색
      // substring, slice의 차이
      // 1. start index > end index인 경우, substring은 start와 end를 바꾸어 결과 출력, slice는 빈 값 출력
      // 2. 음수인 index가 주어지는 경우, substring은 해당 index를 0으로 취급, slice는 가장 마지막 index에서 음수의 절대값을 뺀 값으로 취급
      // 3. slice에서 음수인 index를 변환하니 start index > end index인 경우, substring처럼 해당 음수 index를 0으로 취급한다.

      // replace
      // 만약 AAABBBCCCBBB에서 단순히 replace("BBB", "FFF")를 하면 AAAFFFCCCBBB처럼 뒤 BBB는 변하지 않는다.
      // replaceAll을 사용하거나 정규 표현식으로 모든 문자를 체크하도록 해야한다.
      const text2 = "AAABBBCCCBBB";

      console.log(text2.replace("BBB", "FFF"));
      console.log(text2.replaceAll("BBB", "FFF"));
      console.log(text2.replace(/BBB/g, "FFF"));

      console.log(text.toUpperCase());
      console.log(text.toLowerCase());

      console.log(text.includes("A"));
      console.log(text.includes("T"));

      console.log(text.split(""));

      console.log("    abc".trim());
      console.log("    abc   ".trim());
      console.log("    a b c".trim());
      // trim은 앞 뒤 공백을 제거함
    </script>
  </body>
</html>
